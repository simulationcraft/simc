# This is a little script to synchronize our various build files.
#
# How it works:
# 1) Edit Qt .pri files
# 2) Run this script with python3
# 3) output: reformatted, Qt, Visual Studio ( cli only ), POSIX Makefile

import re
import datetime
import sys

def parse_qt( filename ):
    f = open( filename, "r" )
    out = []
    if f:
        for line in f:
            match = re.search ( r"(\s*)(SOURCES|HEADERS|PRECOMPILED_HEADER)(\s*\+?\=\s*)([\w\/]*?)([\w]*)(\.\w*)", line )
            if match:
                out.append( ( match.group(2), match.group(4) + match.group(5) + match.group(6), match.group(4), match.group(5), match.group(6) ) )
        f.close()
    return out


def header( system ):
    if system == "VS":
        h = "<!--\n"
    else:
        h = "# "
    h += "This file is automatically generated by " + sys.argv[0] + "\n"
    
    # if system != "VS":
    #     h += "# "
    # h += "Last updated: " + str(datetime.datetime.now() ) + "\n\n"
    
    if system != "VS":
        h += "# "
    h += "To change the list of source files, update the QT_ files and run " + sys.argv[0]
    if system == "VS":
        h += "\n-->"
    h += "\n\n"
    return h

def write_to_file( filename, out ):
    f = open( filename, "w" )
    if f:
        f.write( out )
        f.close()

def create_qt_str( input ):
    prepare = header( "QT" )
    for entry in input:
        if entry[0] == "SOURCES" or entry[0] == "HEADERS" or entry[0] == "PRECOMPILED_HEADER":
            prepare += "\n " + entry[0] + " += " + entry[1]
    return prepare


def create_make_str( input ):
    modified_input = replace( input, r"engine/", r"" )
    modified_input = replace( modified_input , r"/" , r"$(PATHSEP)" )
    prepare = header( "Makefile" )
    prepare += "SRC += \\"
    for entry in modified_input:
        if entry[0] == "SOURCES" or entry[0] == "HEADERS":
            prepare += "\n    " + entry[1] + " \\"
    return prepare

def VS_no_precompiled_header():
    return "<PrecompiledHeader>NotUsing</PrecompiledHeader>"
    
# Determine what precompiled header setting to use
def VS_use_precompiled_header( filename ):
    if re.search( r"sc_player.cpp", filename ):
        return "<PrecompiledHeader>Create</PrecompiledHeader>"
    transformed_filename = re.sub( r"\\", "/", filename )
    with open( transformed_filename ) as f:
          content = f.read()
          if re.search( r"#include \"simulationcraft.hpp\"", content ):
            return "" #"<PrecompiledHeader />"
          else:
            return VS_no_precompiled_header()
            
    print "could not open file for precompiled header settings!"
    return ""
        
def VS_header_str( filename, gui ):
	if gui:
		moced_name = "moc_" + re.sub( r".*\\(.*?).hpp", r"\1.cpp", filename )
		return "\n\t\t<ClCompile Include=\"$(IntDir)" + moced_name + "\">\n\t\t\t" + VS_no_precompiled_header() + "\n\t\t</ClCompile>"
	else:
		return  "\n\t\t<ClInclude Include=\"" + filename + "\" />";
		
def create_vs_str( input, gui = False ):
    modified_input = replace( input, r"^", r"..\\" )
    modified_input = replace( modified_input , r"/" , r"\\" )
    prepare = header( "VS" )
    prepare += """<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
\t<ItemGroup>"""
    for entry in modified_input:
        if re.search( r"sc_io.cpp", entry[1] ):
            prepare += "\n\t\t<ClCompile Include=\"" + entry[1] + "\">\n\t\t\t" + VS_use_precompiled_header( entry[1] ) + "\n\t\t</ClCompile>"
        elif entry[0] == "HEADERS":
            prepare += VS_header_str( entry[1], gui )
        elif entry[0] == "SOURCES":
            prepare += "\n\t\t<ClCompile Include=\"" + entry[1] + "\">\n\t\t\t" + VS_use_precompiled_header( entry[1] ) + "\n\t\t</ClCompile>"
    prepare += "\n\t</ItemGroup>"
	
    if gui:

        # Gui Resources
        prepare += "\n\n\t<!--Resources -->"
        prepare += "\n\t<ItemGroup>"
        prepare += "\n\t\t<ResourceCompile Include=\"..\simcqt.rc\" />"
        prepare += "\n\t</ItemGroup>"
        
        prepare += "\n\n"
        
        # Moc Defines
        prepare += "\t<!-- Moc Definitions -->"
        
        prepare += "\n\t<PropertyGroup Label=\"UserMacros\" Condition=\"'$(Configuration)'=='Debug'\">"
        prepare += "\n\t\t<MOC_DEFINES>-DUNICODE -DWIN32 -DWIN64 -DQT_VERSION_5 -DQT_QML_DEBUG -DQT_DECLARATIVE_DEBUG -DQT_WIDGETS -DQT_WEBKITWIDGETS_LIB -DQT_QUICK_LIB -DQT_MULTIMEDIAWIDGETS_LIB -DQT_OPENGL_LIB -DQT_PRINTSUPPORT_LIB -DQT_QML_LIB -DQT_MULTIMEDIA_LIB -DQT_WEBKIT_LIB -DQT_WIDGETS_LIB -DQT_SENSORS_LIB -DQT_NETWORK_LIB -DQT_GUI_LIB -DQT_CORE_LIB -DQT_OPENGL_ES_2 -DQT_OPENGL_ES_2_ANGLE -D_MSC_VER=1700 -D_WIN32 -D_WIN64</MOC_DEFINES>"
        prepare += "\n\t</PropertyGroup>"
        
        prepare += "\n\t<PropertyGroup Label=\"UserMacros\" Condition=\"'$(Configuration)'=='Release'\">"
        prepare += "\n\t\t<MOC_DEFINES>-DUNICODE -DWIN32 -DWIN64 -DQT_VERSION_5 -DQT_NO_DEBUG -DQT_WEBKITWIDGETS_LIB -DQT_WIDGETS -DQT_QUICK_LIB -DQT_MULTIMEDIAWIDGETS_LIB -DQT_OPENGL_LIB -DQT_PRINTSUPPORT_LIB -DQT_QML_LIB -DQT_MULTIMEDIA_LIB -DQT_WEBKIT_LIB -DQT_WIDGETS_LIB -DQT_SENSORS_LIB -DQT_NETWORK_LIB -DQT_GUI_LIB -DQT_CORE_LIB -DQT_OPENGL_ES_2 -DQT_OPENGL_ES_2_ANGLE -D_MSC_VER=1700 -D_WIN32 -D_WIN64</MOC_DEFINES>"
        prepare += "\n\t</PropertyGroup>"

        prepare += "\n\n"
            
        # Moc extra build steps
        prepare += "\t<!-- Moc'ing GUI Header files -->"
        prepare += "\n\t<ItemGroup>"
        
        for entry in modified_input:
            if entry[0] == "HEADERS":
                prepare += """
\t\t<CustomBuild Include=\"""" + entry[1] + """\">
\t\t\t<AdditionalInputs>$(QTDIR)\\bin\moc.exe</AdditionalInputs>
\t\t\t<Message>Moc%27ing %(Identity)... ( with $(QTDIR)\\bin\moc.exe )</Message>
\t\t\t<Command>"$(QTDIR)\\bin\\moc.exe" $(MOC_DEFINES) -I"$(QTDIR)\\include" -I"(SolutionDir)engine" -I"$(QTDIR)\\mkspecs\\default" "%(Identity)" -o "$(IntDir)moc_%(Filename).cpp" </Command>
\t\t\t<AdditionalInputs>Rem;""" + entry[1] + """;%(AdditionalInputs)</AdditionalInputs>
\t\t\t<Outputs>$(IntDir)\\moc_%(Filename).cpp</Outputs>
\t\t</CustomBuild>"""
        
        
        prepare += "\n\t</ItemGroup>"
        
		
    prepare += "\n</Project>"
    return prepare
        
def replace( input, separator, repl ):
    r = []
    for entry in input:
        r.append( ( entry[0], re.sub( separator, repl, entry[1] ) ) )
    return r

def sort_by_name( input ):
    input.sort( key=lambda entry : entry[3], reverse=True )
    input.sort( key=lambda entry : entry[2], reverse=True )
    input.sort( key=lambda entry : entry[4], reverse=True )

def create_file( file_type, build_systems ):
    result = parse_qt( "QT_" + file_type + ".pri" )
    # print result
    sort_by_name( result )
    if "make" in build_systems:
        write_to_file( file_type + "_make", create_make_str( result ) )
    if "VS" in build_systems:
        write_to_file( "VS_" + file_type + ".props", create_vs_str( result ) )
    if "VS_GUI" in build_systems:
        write_to_file( "VS_" + file_type + ".props", create_vs_str( result, True ) )
    if "QT" in build_systems:
        write_to_file( "QT_" + file_type + ".pri", create_qt_str( result ) )
    
def main():
    create_file( "engine", ["make","VS", "QT"] )
    create_file( "engine_main", ["make","VS", "QT"] )
    create_file( "gui", ["QT","VS_GUI"] ) # TODO: finish mocing part of VS_GUI
    print "done"
    
if __name__ == "__main__":
    main()
            
